# 워크플로우의 이름을 지정합니다. GitHub Actions 탭에 이 이름이 표시됩니다.
name: Spring Backend CI/CD (Blue/Green)

# 워크플로우가 언제 실행될지를 정의합니다.
on:
  # 'main' 브랜치에 코드가 푸시될 때
  push:
    branches:
      - main
    # 단, 변경된 파일이 'backend/' 폴더 내에 있을 경우에만 실행됩니다.
    paths:
      - 'backend/**'

# 실행될 작업(job)들을 정의합니다.
jobs:
  # 'build-and-deploy' 라는 이름의 작업을 정의합니다.
  build-and-deploy:
    # 이 작업이 실행될 러너(Runner)를 지정합니다. EC2에 설치한 self-hosted 러너를 사용합니다.
    runs-on: self-hosted

    # 작업 내에서 실행될 단계(step)들을 순서대로 정의합니다.
    steps:
    # 1. 코드 체크아웃: GitHub 저장소의 코드를 러너(EC2)로 가져옵니다.
    - name: Checkout code
      uses: actions/checkout@v3

    # 2. GHCR 로그인: Docker 이미지를 푸시하기 위해 GitHub Container Registry에 로그인합니다. (누락되었던 부분)
    - name: Login to GitHub Container Registry
      uses: docker/login-action@v2
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GHCR_TOKEN }} # 저장소에 등록한 GHCR_TOKEN 시크릿 사용

    # 3. Docker Buildx 설정: 고급 캐싱 기능을 지원하는 Docker 빌드 엔진을 설정합니다. (오류 해결)
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    # 4. Docker 이미지 빌드 및 푸시: Spring 애플리케이션을 Docker 이미지로 만들고 GHCR에 업로드합니다.
    - name: Build and push Spring Docker image
      uses: docker/build-push-action@v4
      with:
        context: ./backend # Dockerfile이 있는 backend 폴더를 지정합니다.
        push: true # 빌드 후 이미지를 GHCR에 푸시합니다.
        # 이미지 태그를 일관성 있게 수정 (소문자 권장)
        tags: ghcr.io/seoulbhin/cleanup-street-react:latest
        cache-from: type=gha # GitHub Actions 캐시를 사용하여 빌드 속도를 높입니다.
        cache-to: type=gha,mode=max

    # 5. 블루/그린 전략으로 배포: EC2 서버에서 무중단 배포 스크립트를 실행합니다.
    - name: Deploy with Blue/Green Strategy
      run: |
        echo "Starting Spring Backend Blue/Green Deployment..."

        # 현재 서비스 중인 컨테이너(blue)가 있는지 확인합니다.
        EXISTING_BLUE=$(docker ps -q -f name=cleanup-street-spring-blue)
        
        # 다음 배포 환경(blue 또는 green)과 포트를 결정합니다.
        if [ -z "$EXISTING_BLUE" ]; then
          NEW_COLOR="blue"
          OLD_COLOR="green"
          NEW_PORT=9090
        else
          NEW_COLOR="green"
          OLD_COLOR="blue"
          NEW_PORT=9091
        fi

        echo "Deploying new Spring app to ${NEW_COLOR} on EC2 host port ${NEW_PORT}"
        
        # 새 버전의 Docker 이미지를 가져와 새 컨테이너를 실행합니다.
        docker pull ghcr.io/${{ github.repository_owner }}/cleanup-street-spring:latest
        docker run -d \
                   --name cleanup-street-spring-${NEW_COLOR} \
                   -p ${NEW_PORT}:8080 \
                   ghcr.io/${{ github.repository_owner }}/cleanup-street-spring:latest

        # 헬스 체크: 새 컨테이너가 정상적으로 실행되는지 확인합니다.
        echo "Waiting for Spring app on port ${NEW_PORT} to be healthy..."
        sleep 15
        for i in {1..20}; do
          RESPONSE_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:${NEW_PORT}/actuator/health)
          if [ "$RESPONSE_CODE" -eq 200 ]; then
            echo "Health check passed!"

            # 트래픽 전환: Nginx 설정을 변경하여 사용자의 요청을 새 컨테이너로 보냅니다.
            echo "Switching Nginx traffic to port ${NEW_PORT}"
            echo "upstream spring_servers { server 127.0.0.1:${NEW_PORT}; }" | sudo tee /etc/nginx/conf.d/spring-upstream.conf
            sudo systemctl reload nginx

            # 이전 버전 컨테이너를 중지하고 삭제합니다.
            OLD_CONTAINER=$(docker ps -q -f name=cleanup-street-spring-${OLD_COLOR})
            if [ -n "$OLD_CONTAINER" ]; then
              echo "Stopping and removing old container: cleanup-street-spring-${OLD_COLOR}"
              docker stop cleanup-street-spring-${OLD_COLOR}
              docker rm cleanup-street-spring-${OLD_COLOR}
            fi
            echo "Spring Backend Deployment successful!"
            exit 0 # 성공적으로 종료
          fi
          echo "Health check attempt $i failed (HTTP Code: $RESPONSE_CODE). Retrying..."
          sleep 5
        done
        
        # 헬스 체크 실패 시 롤백: 새로 띄운 컨테이너를 삭제하고 배포를 실패 처리합니다.
        echo "Health check failed. Rolling back."
        docker stop cleanup-street-spring-${NEW_COLOR}
        docker rm cleanup-street-spring-${NEW_COLOR}
        exit 1 # 실패로 종료
